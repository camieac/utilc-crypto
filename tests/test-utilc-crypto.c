/**
* @file test-utilc-template.c
* @author Cameron A. Craig
* @date 28 Dec 2016
* @version 0.1.0
* @copyright 2016 Cameron A. Craig
* @brief Unit tests for utilc-template.
* -- RULE_3_2_CD_do_not_use_special_characters_in_filename
* -- RULE_8_1_A_provide_file_info_comment

* @note Check unit test documentation can be cound here:
* https://libcheck.github.io/check/doc/check_html/index.html#Top
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <check.h>

#include "utilc-crypto.h"

/************************
* Globals
************************/

//Temporary variables
// static unsigned char plaintext[16] = "abcdefghijklmnop";
// static unsigned char plaintext2[16] = "bcdefghijklmnopq";
// static unsigned char key[16] = "000000000000000";
// static unsigned char iv[16] = "000000000000000";
// static unsigned char ciphertext[16] = "";

struct uc_crypto_options opts;

/************************
* Test Case setup and teardown
************************/

/**
* @brief Setup
* @details Checked fixture: Runs for each unit test.
*/
void uc_api_test_setup(void){
	memset(&opts, sizeof(opts), 0);
}

/**
* @brief Teardown
* @details Checked fixture: Runs for each unit test.
*/
void uc_api_test_teardown(void){
	memset(&opts, sizeof(opts), 0);
}

/************************
* Unit Tests
************************/

// START_TEST (test_aes_ecb){
// 	uint8_t ecb_key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	uint8_t ecb_plaintext[]  = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
// 	uint8_t ecb_ciphertext[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};
// 	unsigned char buffer[16];
//
//
//
// 	//Encrypt, writing ciphertext to ciphertext
// 	uc_crypto_cipher(ecb_plaintext, buffer, ecb_key, &opts);
//
// 	//Check that the encrypted plaintext matches the expecte ciphertext
// 	fail_if(memcmp(buffer, ecb_ciphertext, 16) != 0);
//
// 	//Decrypt the ciphertext to a secondary location
// 	opts.op = DECRYPT;
// 	uc_crypto_cipher(buffer, buffer, ecb_key, &opts);
//
// 	//Check that the decrypted ciphertext matches the original plaintext
// 	fail_if(memcmp(buffer, ecb_plaintext, 16) != 0);
// }
// END_TEST
//
// START_TEST (test_aes_cbc){
// 	//Set up AES (ECB) 16-byte encrypt
// 	opts = (struct uc_crypto_options) {
// 		.cipher = AES_CBC,
// 		.op = ENCRYPT,
// 		.impl = SW,
// 		.iv = iv,
// 		.cipher_len = 16
// 	};
//
// 	//Encrypt, writing ciphertext to ciphertext
// 	uc_crypto_cipher(plaintext, ciphertext, key, &opts);
//
// 	//Decrypt the ciphertext to a secondary location
// 	opts.op = DECRYPT;
// 	uc_crypto_cipher(ciphertext, plaintext, key, &opts);
//
// 	//Check that the decrypted ciphertext matches the original plaintext
// 	fail_if(memcmp(plaintext2, plaintext, 16) != 0);
// }
// END_TEST

// START_TEST (test_aes_ecb_16){
// 	uint8_t ecb_16_key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	uint8_t ecb_16_plaintext[]  = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
// 	uint8_t ecb_16_ciphertext[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};
// 	unsigned char buffer[16];
//
// 	AES128_ECB_encrypt(plaintext, ecb_16_key, buffer);
//
// 	//Check that the decrypted ciphertext matches the original plaintext
// 	fail_if(memcmp(ecb_16_ciphertext, buffer, 16) != 0);
//
// 	AES128_ECB_decrypt(buffer, ecb_16_key, buffer);
//
// 	//Check that the decrypted ciphertext matches the original plaintext
// 	fail_if(memcmp(ecb_16_plaintext, buffer, 16) != 0);
// }
// END_TEST

// START_TEST (test_aes_128_ecb_16_encrypt) {
// 	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
// 	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	unsigned char plaintext[]  = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
// 	unsigned char ciphertext[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};
// 	unsigned char buffer[16];
//
// 	aes_ecb_encrypt_block(plaintext, key, buffer);
// 	fail_if(memcmp(ciphertext, buffer, 16) != 0);
// }
// 	END_TEST
//
// START_TEST (test_aes_128_ecb_16_decrypt) {
// 	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
// 	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	unsigned char ciphertext[]  = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97};
// 	unsigned char plaintext[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a};
// 	unsigned char buffer[16];
//
// 	aes_ecb_decrypt_block(ciphertext, key, buffer);
// 	fail_if(memcmp(plaintext, buffer, 16) != 0);
// }
// END_TEST
//
// START_TEST (test_aes_128_ecb_64_encrypt) {
// 	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
// 	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	unsigned char plaintext[]  = {
// 		0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
// 		0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
// 		0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
// 		0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
// 	};
//
// 	unsigned char ciphertext[] = {
// 		0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
// 		0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
// 		0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
// 		0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
// 	};
// 	unsigned char buffer[64];
//
// 	aes_ecb_encrypt_buffer(buffer, plaintext, 64, key);
// 	fail_if(memcmp(ciphertext, buffer, 64) != 0);
// }
// 	END_TEST
//
// START_TEST (test_aes_128_ecb_64_decrypt) {
// 	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
// 	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
// 	unsigned char plaintext[]  = {
// 		0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
// 		0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
// 		0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
// 		0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
// 	};
//
// 	unsigned char ciphertext[] = {
// 		0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
// 		0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
// 		0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
// 		0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
// 	};
// 	unsigned char buffer[64];
//
// 	aes_ecb_decrypt_buffer(buffer, ciphertext, 64, key);
// 	fail_if(memcmp(plaintext, buffer, 64) != 0);
// }
// END_TEST

/******************************************
 * ECB Test Vectors
 *****************************************/

unsigned char ecb_tv_key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
unsigned char ecb_tv_plaintext[]  = {
	 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
	 0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
	 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
	 0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
 };

unsigned char ecb_tv_ciphertext[] = {
	 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
	 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
	 0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
	 0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
 };

START_TEST (test_aes_128_ecb_api_encrypt) {
	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
	unsigned char buffer[64];

	struct uc_crypto_options opts = {
		.cipher = AES_ECB,
		.cipher_len = 64,
		.op = ENCRYPT,
		.impl = SW,
		.key = ecb_tv_key,
		.key_len = 16,
	};

	uc_crypto_cipher(ecb_tv_plaintext, buffer, &opts);
	fail_if(memcmp(ecb_tv_ciphertext, buffer, 64) != 0);
}
	END_TEST

START_TEST (test_aes_128_ecb_api_decrypt) {
	unsigned char buffer[64];

	struct uc_crypto_options opts = {
		.cipher = AES_ECB,
		.cipher_len = 64,
		.op = DECRYPT,
		.impl = SW,
		.key = ecb_tv_key,
		.key_len = 16,
	};

	uc_crypto_cipher(ecb_tv_ciphertext, buffer, &opts);
	fail_if(memcmp(ecb_tv_plaintext, buffer, 64) != 0);
}
END_TEST

START_TEST (test_aes_128_cbc_api_encrypt) {
	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
	unsigned char plaintext[]  = {
		0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
		0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
		0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
		0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
	};

	unsigned char ciphertext[] = {
		0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
		0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
		0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
		0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
	};
	unsigned char buffer[64];

	struct uc_crypto_options opts = {
		.cipher = AES_ECB,
		.cipher_len = 64,
		.op = ENCRYPT,
		.impl = SW,
		.key = key,
		.key_len = 16,
	};

	uc_crypto_cipher(plaintext, buffer, &opts);
	fail_if(memcmp(ciphertext, buffer, 64) != 0);
}
	END_TEST

START_TEST (test_aes_128_cbc_api_decrypt) {
	//See http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf, Appendix F for example test vectors
	unsigned char key[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
	unsigned char plaintext[]  = {
		0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
		0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
		0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
		0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
	};

	unsigned char ciphertext[] = {
		0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
		0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
		0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
		0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
	};
	unsigned char buffer[64];

	struct uc_crypto_options opts = {
		.cipher = AES_ECB,
		.cipher_len = 64,
		.op = DECRYPT,
		.impl = SW,
		.key = key,
		.key_len = 16,
	};

	uc_crypto_cipher(ciphertext, buffer, &opts);
	fail_if(memcmp(plaintext, buffer, 64) != 0);
}
END_TEST



/**
* @brief Defines test suite for utilc-template lib.
*/
Suite* utilc_test_suite (void) {
				Suite *suite = suite_create("utilc_timing_test_suite");

				// TCase *aes_api_tcase = tcase_create("AES API Test Case");
				// tcase_add_checked_fixture(aes_api_tcase, uc_api_test_setup, uc_api_test_teardown);
				// tcase_add_test(aes_api_tcase, test_aes_ecb);
				// tcase_add_test(aes_api_tcase, test_aes_cbc);
				// suite_add_tcase(suite, aes_api_tcase);
				// #if 0
				// TCase *aes_128_16_tcase = tcase_create("128-bit ECB Tests (Single Block)");
				// tcase_add_test(aes_128_16_tcase, test_aes_128_ecb_16_encrypt);
				// tcase_add_test(aes_128_16_tcase, test_aes_128_ecb_16_decrypt);
				// suite_add_tcase(suite, aes_128_16_tcase);
				//
				// TCase *aes_128_64_tcase = tcase_create("128-bit ECB Tests (Multiple Blocks)");
				// tcase_add_test(aes_128_64_tcase, test_aes_128_ecb_64_encrypt);
				// tcase_add_test(aes_128_64_tcase, test_aes_128_ecb_64_decrypt);
				// suite_add_tcase(suite, aes_128_64_tcase);
				// #endif

				TCase *aes_128_ecb_api_tcase = tcase_create("128-bit API AES ECB Tests (Multiple Blocks)");
				tcase_add_test(aes_128_ecb_api_tcase, test_aes_128_ecb_api_encrypt);
				tcase_add_test(aes_128_ecb_api_tcase, test_aes_128_ecb_api_decrypt);
				suite_add_tcase(suite, aes_128_ecb_api_tcase);

				TCase *aes_128_cbc_api_tcase = tcase_create("128-bit API AES CBC Tests (Multiple Blocks)");
				tcase_add_test(aes_128_cbc_api_tcase, test_aes_128_cbc_api_encrypt);
				tcase_add_test(aes_128_cbc_api_tcase, test_aes_128_cbc_api_decrypt);
				suite_add_tcase(suite, aes_128_cbc_api_tcase);

				// TCase *aes_128_64_tcase = tcase_create("192-bit API AES ECB Tests (Multiple Blocks)");
				// tcase_add_test(aes_128_64_tcase, test_aes_192_ecb_api_encrypt);
				// tcase_add_test(aes_128_64_tcase, test_aes_192_ecb_api_decrypt);
				// suite_add_tcase(suite, aes_128_64_tcase);
				//
				// TCase *aes_128_64_tcase = tcase_create("256-bit API AES ECB Tests (Multiple Blocks)");
				// tcase_add_test(aes_128_64_tcase, test_aes_256_ecb_api_encrypt);
				// tcase_add_test(aes_128_64_tcase, test_aes_256_ecb_api_decrypt);
				// suite_add_tcase(suite, aes_128_64_tcase);

				return suite;
}

/**
* @brief Run the full test suite.
* @returns Number of tests failed.
*/
uint32_t main (uint32_t argc, char *argv[]) {
				uint32_t number_failed;
				Suite *suite = utilc_test_suite();
				SRunner *runner = srunner_create(suite);
				srunner_run_all(runner, CK_NORMAL);
				number_failed = srunner_ntests_failed(runner);
				srunner_free(runner);
				return number_failed;
}
